
<#@ template language="C#" debug="True" hostspecific="true"#>
<#@ output extension="log" #>
<#@ import namespace="System.Collections"#>
<#@ import namespace="System.Collections.Generic"#>
<#@ import namespace="System.Text"#>
<#@ import namespace="System.Linq"#>
<#@ import namespace="System.Reflection"#>
<#
//     .Net to Objective-C code generator
//
//     This template will generate Objective-C bindings  for each class
//     defined in the input assembly file.
//
//     The wrapper files will generate references to the mono Dubrovnik project to provide
//     access to embedded Mono runtime structures.
//
//      refs:
//      Generating multiple outputs
//      http://www.olegsych.com/2008/03/how-to-generate-multiple-outputs-from-single-t4-template/
//      Dealing with complexity
//      http://msdn.microsoft.com/en-us/magazine/hh975350.aspx
//

// This control block code will be integrated into the TransformText method of Net2ObjC.cs
_TransformText();

#>
<#+
//
// Class feature control blocks.
//

//
//  WriteFileBanner() 
//
void WriteFileBanner() 
{
#>
//------------------------------------------------------------------------------
// <auto-generated tool="<#=GenToolName#>">
//
// <#=OutputFileType == OutputType.Implementation ? ImplementationFile : InterfaceFile #>
//
// Dubrovnik based OS X Cocoa Objective-C to Mono bindings.
//
// This code was generated using a tool available as part of:
// http://github.com/ThesaurusSoftware/Dubrovnik
// This code has dependencies on the above project.
//
// Date:     <#=TimeStamp#>
//
// Assembly: <#=AssemblyFacet.Name#>
// Fullname: <#=AssemblyFacet.FullName#>
// Path:     <#=AssemblyFacet.Path#>
//
// Platform: <#=Environment.OSVersion.VersionString#>
// OS Arch:  <#=Environment.Is64BitOperatingSystem ? "64 bit" : "32 bit"#>
// Process:  <#=Environment.Is64BitProcess ? "64 bit" : "32 bit"#>
// Target:   <#=GetTargetFrameworkVersion()#>
// Runtime:  <#=Environment.Version.ToString()#>
<#+
	// write references info	
	foreach (CodeFacet reference in AssemblyFacet.References)
	{
#>
//
// Asm Ref:  <#=reference.Name#>
// Fullname: <#=reference.FullName#>
<#+
	}
#>
//
// Manual changes to this file may cause unexpected behavior in your application.
// Manual changes to this file will be overwritten if the code is regenerated.
//
// </auto-generated>
//------------------------------------------------------------------------------
<#+
}

//
// WriteModuleBanner
//
public void WriteModuleBanner(CodeFacet facet, string module)
{
	string outputFile = facet.OutputFileName() + OutputFileSuffix();

	// There is an argument that says - Lets add the date here!
	// However this leads to what I think are excessively noisey commits.
#>

//++<#=GenToolName#> <#=outputFile#>
//
// Managed <#=module#> : <#=facet.Name#>
//
<#+	
	if (OutputFileType == OutputType.Implementation)
    {
		WriteModuleFeatureRequirements();
    }
}

//
// WriteModuleFooter
//
public void WriteModuleFooter()
{
#>
//--<#=GenToolName#>
<#+	
}
//
// WriteInterfaceFilePreliminaries
//
public void WriteInterfaceFilePreliminaries()
{
	string objCAssemblyHeaderName = ObjCIdentifierFromManagedIdentifier(AssemblyFacet.Name);
	string defineName = ("Include_" + objCAssemblyHeaderName + "_Extra").ToUpper();
	
#>
#import <Cocoa/Cocoa.h>
#import <Dubrovnik/Dubrovnik.h>

//
// Extra include
//
#ifdef <#=defineName#>
#import "<#=objCAssemblyHeaderName#>.__Extra__.h"	// Not auto generated. Add manually to project.
#endif

<#+
	if ( AssemblyFacet.References.Count() > 0) 
	{
#>

//
// Referenced assemblies
//
<#+
    }

	foreach (CodeFacet reference in AssemblyFacet.References)
	{
		string includeFile = reference.Name;
		defineName = (ObjCIdentifierFromManagedIdentifier(includeFile) + "_Included").ToUpper();
#>
#ifndef <#=defineName#>
//#import "<#=includeFile#>.h"
#endif

<#+  
	}

	bool commentOutput = false;
	foreach (NamespaceFacet @namespace in AssemblyFacet.Namespaces)
	{
		// collect facets that render as Obj-C classes
		IList<CodeFacet> facets = new List<CodeFacet>();
		facets.AddRange(@namespace.Classes);
		facets.AddRange(@namespace.Interfaces);
		facets.AddRange(@namespace.Structs);
		if (ImplementEnumerationsAsClasses) 
		{
			facets.AddRange(@namespace.Enumerations);
        }

		// write class predeclarations 
		if (facets.Count() > 0 && !commentOutput) 
		{
#>

//
// Forward class declarations and class aliases
//
<#+     
			commentOutput = true;   
		}

		foreach (CodeFacet facet in facets)
		{
			WriteClassPredeclaration(facet);
		}	
	}	
}

//
// WriteClassPredeclaration
//
public void WriteClassPredeclaration(CodeFacet facet)
{
	string namespacePrefix = ObjCAcronymFromManagedIdentifier(facet.TypeNamespace);
	string classDefine = ObjCIdentifierFromManagedIdentifier(namespacePrefix + facet.Name) + "_";
	string classObjCType = facet.ObjCFacet.Type;

#>
@class <#=classObjCType#>;
#ifdef <#=classDefine#>
#warning <#=classDefine#> class name collision.
#else
#define <#=@classDefine#> <#=@classObjCType#>
#endif

<#+	
}

//
// WritePragmaMark
//
public void WritePragmaMark(string info)
{
#>

#pragma mark -
#pragma mark <#=info#>
<#+	
}

//
// WriteCommentBlock
//
public void WriteCommentBlock(string info)
{
#>

/*

<#=info#>

*/
<#+	
}
//
// WriteImplementationFilePreliminaries
//
public void WriteImplementationFilePreliminaries()
{
	WriteModuleFeatureRequirements();
}

//
// WriteModuleFeatureRequirements
//
public void WriteModuleFeatureRequirements()
{
#>

// ARC is required
#if  ! __has_feature(objc_arc)
#error This file requires ARC. 
#endif

<#+
}

//
// WriteInterfaceStart
//
public void WriteInterfaceStart(InterfaceFacet facet, string module, bool writeAux = false)
{
	if (!writeAux) {
		WriteModuleBanner(facet, module);
    }

	// build list of base protocols 
	string baseInterfaces = "NSObject";
	foreach (ImplementedInterfaceFacet interfaceFacet in facet.ImplementedInterfaces) {
		baseInterfaces += ", ";
		baseInterfaces += interfaceFacet.ObjCFacet.Type;
    }

	if (!writeAux) {
#>
@protocol <#=facet.ObjCFacet.Type#> <<#=baseInterfaces#>>

@optional

/*

 .Net support for explicit interfaces means that a class can inherit two or more different
 signatures for the same property or method from two or more interfaces. 
 This is not supported by Objective-C. 

 A second point is that properties declared in protocols don't get their ivars synthesized.
 This causes warnings to be issued when interface properties are exposed explicitly.

 A third point is that even when we receive a managed interface as a return value from a property 
 or method we still need to provide a full binding in order access those properties and methods.

 A fourth point is that in general we will not be defining Obj-C classes that conform to 
 managed protocols.

 These points make the inclusion of the actual content of the protocol somewhat debatable. 

 In general it therefore seems best to omit the accessor predeclarations from the protocol declaration.
 It should still be possible to test for protocol conformance using Class -conformsToProtocol:

 The protocol properties and methods can be conditionally included if required.
 An auxliary protocol definition is also provided.

*/

#ifdef  DEF_P_AND_M_<#=facet.ObjCFacet.Type#>
<#+	
    } else {
	
#>

/*
 
 Auxiliary protocol definition.

*/

@protocol db_aux_<#=facet.ObjCFacet.Type#> <<#=baseInterfaces#>>

@optional

<#+		
	}// if !writeAux

}

//
// WriteInterfaceEnd
//
public void WriteInterfaceEnd(CodeFacet facet, bool writeAux = false)
{
	if (!writeAux) {
#>
#endif

<#+
    } // if !writeAux
#>

@end

<#+
	if (writeAux) {
		WriteModuleFooter();
    }
}


//
// WriteClassStart
//
public void WriteClassStart(CodeFacet facet, string module, bool writeBanner = true)
{
	// Allocate property name list
	this.StaticObjectPropertyStorageNames = new List<string>();

	// prefix defines interface or implementation
	string classPrefix = OutputDeclarationPrefix();
	string superClass = OutputDeclarationSuffix(facet);
	string implementedProtocols = "";

	// implemented protocol support is available but 
	// we may not be quite ready to supply all the framework managed interfaces that
	// are commonly referenced
	bool outputImplementedProtocols = true;
	if (true) {
		implementedProtocols =  OutputImplementedProtocolSuffix(facet);
    }

	 if (writeBanner) {
		WriteModuleBanner(facet, module);
    }
#>
@<#=classPrefix#> <#=facet.ObjCFacet.Type#><#=superClass#><#=implementedProtocols#>
<#+	
	WriteClassSetup(facet);	
}


//
// WriteClassSetup
// 
public void WriteClassSetup(CodeFacet facet)
{
	WritePragmaMark("Setup");
#>
	// obligatory override
	+ (const char *)monoClassName<#=LT#>
<#+
	if (OutputFileType == OutputType.Implementation) 
	{
		string name = CodeFacet.NormalizeGenericTypesInManagedIdentifier(facet.NameFromType);
#>
	{
		return "<#=facet.TypeNamespace#>.<#=name#>";
	}
<#+
    }
#>
	// obligatory override
	+ (const char *)monoAssemblyName<#=LT#>
<#+	
	if (OutputFileType == OutputType.Implementation) 
	{
#>
	{
		return "<#=AssemblyFacet.Name#>";
	}
<#+
    }
}

//
// WriteClassEnd
//
public void WriteClassEnd(CodeFacet facet)
{
	WriteClassTeardown(facet);	
#>
@end
<#+
	WriteModuleFooter();
}

//
// WriteClassTeardown
// 
public void WriteClassTeardown(CodeFacet facet)
{
	if (OutputFileType == OutputType.Implementation) 
	{
	WritePragmaMark("Teardown");
#>
	- (void)dealloc
	{
<#+
		foreach (string staticObjectPropertyName in StaticObjectPropertyStorageNames)
        {
#>
		<#=staticObjectPropertyName#> = nil;
<#+
        }
#>
	}
<#+

	this.StaticObjectPropertyStorageNames = null;
    }
}
//
// WriteEnumeration
//
public void WriteEnumeration(EnumerationFacet enumeration)
{
	string objCEnumType = ObjCTypeNameFromManagedTypeName(enumeration.UnderlyingType);
	string objCType = ObjCTypeNameFromManagedTypeName(enumeration.Type);

	// output the enums as a typedef.
	// note that we could also generate a class based definition.
	// it remains to be seen whether this is necessary.
	if (OutputFileType == OutputType.Interface) 
	{
		if (!ImplementEnumerationsAsClasses) 
		{

			WriteModuleBanner(enumeration, "enumeration");
#>
typedef NS_ENUM(<#=objCEnumType#>, <#=objCType#>) {
<#+
			foreach (FieldFacet field in enumeration.Fields) 
			{
				string objCFieldName = ObjCIdentifierFromManagedIdentifier(field.Name);
#>
	<#=objCType#>_<#=objCFieldName#> = <#=field.ConstantValue#>,
<#+
			}
#>
};
<#+
			WriteModuleFooter();
		}	
		else 
		{
			throw new Exception("Enumerations as classes not implemented");
		}
    } 

}

//
// WriteFacetAsAccessor
// 
public void WriteFacetAsAccessor(CodeFacet facet, Dictionary<string, object> options = null)
{
	// define getters and setters
	string accessorName = facet.Name;
	string accessorDescription = facet is PropertyFacet ? "property" : "field";
	string getterName = accessorName.FirstCharacterToLower();
	string setterName = "set" + accessorName.FirstCharacterToUpper();
	string accessorType = facet.Type;
	string objCTypeDecl = ObjCTypeDeclFromManagedFacet(facet);
	bool isObjectProperty = ObjCRepresentationIsObject(facet);
	string monoObjectPtr = "MonoObject *";

	// property storage and evaluation
	string propertyAttributes = "";
	string propertyStorage = "_" + getterName;
	if (facet.IsStatic) 
	{
		propertyStorage = "m" + propertyStorage;
		if (isObjectProperty) 
        {
			this.StaticObjectPropertyStorageNames.Add(propertyStorage);
        }
    }
	string doPropertyEqualityTest = "";
	if (isObjectProperty) 
	{
		// test if mono object pointer and property storage reference the same managed object
		doPropertyEqualityTest = string.Format("if ([self object:{0} isEqualToMonoObject:{1}]) return {0};", propertyStorage, ManagedVariableName);
    }

	// field access
	string fieldAccessExpression ="";

	// instance property.
	if (!facet.IsStatic) 
	{
		string attributes = "nonatomic";

		// object property attributes
		if (ObjCRepresentationIsObject(facet)) 
		{
			attributes += ", strong";
		}
		if (!facet.IsWritable) 
		{
			attributes += ", readonly";
		} 
		propertyAttributes =  String.Format("({0}) ", attributes);
    }

	// create Obj-C representation of managed object
	string managedValueToObjC = ManagedValueToObjc(ManagedVariableName, facet);
	string objCValueToMono = ObjCValueToManaged(ObjCVariableName, objCTypeDecl, facet);
	ObjCTypeAssociation objCTypeAssociate = ObjCTypeAssociate(facet);

	string objCMethodType = !facet.IsStatic ? "-" : "+";
	string getFormat, setFormat;

	// property
	if (facet is PropertyFacet) 
	{
		if (!facet.IsStatic)
		{
			getFormat = "[self getMonoProperty:\"{0}\"]";
			setFormat = "[self setMonoProperty:\"{0}\" valueObject:{1}]";
		} 
		else 
		{
			getFormat = "[[self class] getMonoClassProperty:\"{0}\"]";
			setFormat = "[[self class] setMonoClassProperty:\"{0}\" valueObject:{1}]";
        }

	} 
	// field
	else if (facet is FieldFacet) 
	{
		if (!facet.IsStatic) 
		{
			getFormat = "[self getMonoField:\"{0}\"]";
			setFormat = "[self setMonoField:\"{0}\" valueObject:{1}]";
		} 
		else 
		{
			getFormat = "[[self class] getMonoClassField:\"{0}\"]";
			setFormat = "[[self class] setMonoClassField:\"{0}\" valueObject:{1}]";
        }
    } 
	// invalid facet
	else 
	{
		throw new Exception("Cannot write facet as accessor");
    }

	// form mono method invocation name.
	// a prefix may be required, for instance when calling explicit interface properties.
	string monoMethodPrefix = "";
	if (options != null) {
		if (options.ContainsKey("cAPIMethodPrefix")) {
			monoMethodPrefix = (string)options["cAPIMethodPrefix"];
        }
    }
	string monoInvocationName = monoMethodPrefix + accessorName;

	string getExpression = String.Format(getFormat, monoInvocationName, ManagedVariableName);
	string setExpression = String.Format(setFormat, monoInvocationName, ManagedVariableName);

	// Info comment
#>

	// Managed <#=accessorDescription#> name : <#=accessorName#>
	// Managed <#=accessorDescription#> type : <#=WriteFacetTypeInfo(facet)#>
<#+	
	// Interface 
	if (OutputFileType == OutputType.Interface) 
	{

		// instance property
		if (!facet.IsStatic) 
		{
#>
    @property <#=propertyAttributes#><#=objCTypeDecl#> <#=getterName#>;
<#+	  
			return;
        }    
	} 
	else 
	{
		// implementation

		// instance property
		if (!facet.IsStatic) 
		{
			// synthesize ivar property storage
#>
    @synthesize <#=getterName#> = <#=propertyStorage#>;
<#+		
		} 
		else 
		{
			// declare static property storage
#>
    static <#=objCTypeDecl#> <#=propertyStorage#>;
<#+      
		}
    }

	//
	// write getter method
	//
	if (facet.IsReadable) 
	{
#>
    <#=objCMethodType#> (<#=objCTypeDecl#>)<#=getterName#><#=LT#>
<#+		
		if (OutputFileType == OutputType.Implementation) 
		{
#>
    {
		<#=monoObjectPtr#><#=ManagedVariableName#> = <#=getExpression#>;
<#+	
			if (isObjectProperty)
			{
#>
		<#=doPropertyEqualityTest#>					
<#+	
			}
#>
		<#=propertyStorage#> = <#=managedValueToObjC#>;

		return <#=propertyStorage#>;
	}
<#+	
		} // if Implementation
    } // if IsReadable

	//
	// write setter method
	//
	if (facet.IsWritable) 
	{
#>
    <#=objCMethodType#> (void)<#=setterName#>:(<#=objCTypeDecl#>)<#=ObjCVariableName#><#=LT#>
<#+
		if (OutputFileType == OutputType.Implementation) 
		{
#>
	{
		<#=propertyStorage#> = <#=ObjCVariableName#>;
		<#=monoObjectPtr#><#=ManagedVariableName#> = <#=objCValueToMono#>;
		<#=setExpression#>;          
	}
<#+
        }  // if Implementation
    } // if IsWritable
}

//
// WriteFacetAsMethod
//
public void WriteFacetAsMethod(MethodFacet facet, Dictionary<string, object> options = null)
{
	// In order to ensure compilation of an assembly and its references 
	// the generated code must resolve all types.
	//
	// The generation of a complete set of methods is obviously desirable
	// but in some cases may not be achievable if a unique method signature 
	// cannot be obtained. 

	// if the method is a duplicate (ie: name, parameter types, return type) 
	// then we have no option but to omit it
	if (facet.IsDuplicateSignatureMethod) 
	{
		this.Warning("Duplicate method omitted : " + facet.Name);
		return;
	}

	// if the facet is overloaded on its signature and differs only in its
	// return type then omit it.
	// This can occur with explicit operators.
	// At present it is unknown if these can be called via the embedded API.
	if (facet.IsOverloadedSignatureMethod) 
	{
		this.Warning("Overloaded signature method omitted : " + facet.Name);
		return;
    }

	string monoMethodName = facet.Name;
	string objCMethodFormat = null;
	string objCMethodName = null;
	bool isConstructorMethod = (facet.Name == null);	// constructor has no method name
	string objCMethodType = facet.IsStatic || isConstructorMethod ? "+" : "-";
	string objCTypeDecl = ObjCTypeDeclFromManagedFacet(facet);	
	string managedValueToObjC = null;

	// instance method requires a name and type
	if (!isConstructorMethod) 
	{

		objCMethodName = monoMethodName.FirstCharacterToLower();

		// create Obj-C representation of mono object
		managedValueToObjC = ManagedValueToObjc(ManagedVariableName, facet);

		if (!facet.IsStatic) 
		{
			objCMethodFormat = "[self invokeMonoMethod:\"{0}({1})\" withNumArgs:{2}]";
		} 
		else 
		{
			objCMethodFormat = "[self invokeMonoClassMethod:\"{0}({1})\" withNumArgs:{2}]";
		}
	}
	 else 
	{

		// this looks like a default constructor
		if (facet.Parameters.Count() == 0) 
		{
			return;
        }

		objCMethodName = "new";

		// a constructor requires no explicit name or type
		objCMethodFormat = "[[self alloc] initWithSignature:\"{1}\" withNumArgs:{2}]";
    }

	// build the parameters
	StringBuilder monoSigBuilder = new StringBuilder();
	StringBuilder objCParameterBuilder = new StringBuilder();
	StringBuilder invokeArgsBuilder = new StringBuilder();
	StringBuilder referencePreProcessBuilder = new StringBuilder();
	StringBuilder referencePostProcessBuilder = new StringBuilder();

	int idx = 0;
	foreach (ParameterFacet parameter in facet.Parameters) 
	{

		// if the mono parameters is passed by ref then strip
		// the suffix to enable type association
		string monoParameterType = parameter.Type;
		if (parameter.IsByRef || parameter.IsPointer) 
		{
			monoParameterType = parameter.ElementType;
        }

		//
		// build the ObjC method interleaved parameter representation
		// eg: name1:(int32_t)p1 name2:(int64_t)p2 name3:(NSString *)p3
		//
		string objCParamTypeDecl = null;
		bool objCParameterIsObject = true;

		//
		// Get the ObjC type associated with the parameter.
		//
		ObjCTypeAssociation objCTypeAssociate = ObjCTypeAssociate(parameter);
		ManagedTypeAssociation managedTypeAssociate = null;
		if (objCTypeAssociate != null) 
		{
			//
			// If the parameter is an array, say Int64[], then its Obj-C rep will be System.Array
			// The mono type association however must reflect the represented type, Int64.
			//
			if (parameter.IsArray) 
			{
				ObjCTypeAssociation objCRepresentedTypeAssociate = ObjCTypeAssociate(parameter.ElementType);
				if (objCRepresentedTypeAssociate != null) 
				{
					managedTypeAssociate = objCRepresentedTypeAssociate.ManagedTypeAssociate;
                }
			}
			
			if (managedTypeAssociate == null) 
			{
				managedTypeAssociate = objCTypeAssociate.ManagedTypeAssociate;
			}

			objCParamTypeDecl =  objCTypeAssociate.ObjCTypeDecl;
			objCParameterIsObject = objCTypeAssociate.IsNSObject;
		} 
		else 
		{
			//
			// Generate default objC representations
			//
			objCParamTypeDecl = ObjCTypeDeclFromManagedFacet(parameter);
			objCParameterIsObject = ObjCRepresentationIsObject(parameter);
        }
		if (parameter.IsByRef || parameter.IsPointer) 
		{
			objCParamTypeDecl += "*";	// add additional indirection
        }

		//
		// Build the mono method argument signature
		// eg: int,long,string
		// Use a type associate if available.
		// If not then default to the parameter type
		//
		if (idx > 0) monoSigBuilder.Append(",");
		string monoMethodParameterType = null;

		if (managedTypeAssociate != null && parameter.IsGenericType == false) 
		{
			 monoMethodParameterType = managedTypeAssociate.ManagedTypeInvoke;
			if (parameter.IsArray)  
			{
				monoMethodParameterType += "[]";
            }
        }

		if (monoMethodParameterType == null) monoMethodParameterType = monoParameterType;
		if (parameter.IsGenericParameter) {

			// in order for the C api to substitute the correct type at run time
			// the generic parameter position needs to be indicated.
			monoMethodParameterType = string.Format(monoMethodParameterType, parameter.GenericParameterPosition);
        }
		monoSigBuilder.Append(monoMethodParameterType);
		if (parameter.IsPointer) 
		{
			monoSigBuilder.Append("*");
        }
		if (parameter.IsByRef) 
		{
			monoSigBuilder.Append("&");	// the signature needs to express by ref
        }

		// Build ObjC parameter name.
		// In order to represent overloaded methods effectively the 
		// ObjC paramter name is constructed as follows:
		// Managed parameter name + Managed parameter type + Ref
		string objCParamName = ObjCIdentifierFromManagedIdentifier(parameter.Name);

		// If the method is overloaded by parameter then make the ObjC method
		// name unique by including type info in the name.
		//
		// Managed methods are overloaded by name only.
		// The Obj-C metjods representation uses interleaved parameters which may
		// be sufficient to produce a unique method signature.
		//
		// If however a managed method overload differs only in the type of its parameters 
		// (the managed method name, parameter count and parameter names all being equal)
		// then the Obj-C interleaved parameters will include type info.
		string objCParamOverloadSuffix = "";
		if (facet.IsOverloadedParameterMethod) 
		{
			// We adopt a minimal as opposed to a full type repesentation here in order
			// to minimize the parameter length.
			// Time will tell how it flies.
			objCParamOverloadSuffix = ObjCMinimalIdentifierFromManagedIdentifier(monoMethodParameterType);
        }
		if (parameter.IsByRef) 
		{
			objCParamOverloadSuffix += "Ref";
        }
		if (objCParamOverloadSuffix.Length > 0) 
		{
			objCParamName += objCParamOverloadSuffix.FirstCharacterToUpper();
        }

		// append the complete interleaved parameter expression
		if (idx == 0) 
		{
			if (AppendFirstArgSignatureToMethodName) 
			{
				// the leading underscore helps identify the preceding characters as the managed method name
				objCMethodName += "_with";
				objCParameterBuilder.AppendFormat("{0}", objCParamName.FirstCharacterToUpper());
            } 
        } 
		else 
		{
			objCParameterBuilder.AppendFormat(" {0}", objCParamName.FirstCharacterToLower());
        }
		objCParameterBuilder.AppendFormat(":({0})p{1}", objCParamTypeDecl, idx + 1);

		//
		// build the mono invocation argument representation
		// eg: DB_VALUE(p1), DB_VALUE(p2), [p3 monoValue]
		//
		string argFormat = null;
		if (idx > 0) invokeArgsBuilder.Append(", ");
		if (objCParameterIsObject) 
		{
			if (parameter.IsByRef) {
				argFormat = "&refPtr{0}";	// use reference pointer
            } else {
				argFormat = "[p{0} monoValue]";
            }
        } 
		else 
		{
			if (parameter.IsByRef || parameter.IsPointer) 
			{
				argFormat = "p{0}";	// just pass the pointer
            } 
			else 
			{
				argFormat = "DB_VALUE(p{0})";	// DB_VALUE equates to &
            }
		}
		invokeArgsBuilder.AppendFormat(argFormat, idx + 1);

		//
		// Build reference parameter pre and post process assignment statements
		//
		// Reference parameters need to be assigned to temporary variables
		// to allow for their mutation
		//
		if (objCParameterIsObject && parameter.IsByRef) {

			// dereference and assign temporary variable
			string preProcess = string.Format("void *refPtr{0} = [*p{0} monoValue];{1}", idx + 1, Environment.NewLine);
			referencePreProcessBuilder.Append(preProcess);

			// create new object subclass for reference 
			string postProcess = string.Format("*p{0} = [System_Object subclassObjectWithMonoObject:refPtr{0}];{1}", idx + 1, Environment.NewLine);
			referencePostProcessBuilder.Append(postProcess);
        }

		idx++;
    }

	// finalize argument list representations
	string monoMethodSig = monoSigBuilder.ToString();
	string objCMethodParameters = objCParameterBuilder.ToString();
	string invokeArgs = facet.Parameters.Count().ToString();
	if (facet.Parameters.Count() > 0) 
	{
		invokeArgs += ", " + invokeArgsBuilder.ToString();
    }

	// form mono method invocation name.
	// a prefix may be required, for instance when calling explicit interface methods.
	string monoMethodPrefix = "";
	if (options != null) {
		if (options.ContainsKey("cAPIMethodPrefix")) {
			monoMethodPrefix = (string)options["cAPIMethodPrefix"];
        }
    }
	string monoInvocationName = monoMethodPrefix + monoMethodName;

	string getExpression = String.Format(objCMethodFormat, monoInvocationName, monoMethodSig, invokeArgs) + ";";
	if (referencePostProcessBuilder.Length > 0) {
		getExpression += Environment.NewLine;
    }

	// validation
	if (isConstructorMethod && String.IsNullOrEmpty(monoMethodSig)) throw new Exception("Mono method argument signature is empty");
	if (String.IsNullOrEmpty(objCTypeDecl)) throw new Exception("ObjC type Declaration is empty");    
	if (String.IsNullOrEmpty(objCMethodName)) throw new Exception("Method name is empty"); 
	if (String.IsNullOrEmpty(getExpression)) throw new Exception("Get expression is empty"); 

	//
	// write method
	//
#>

	// Managed method name : <#=isConstructorMethod ? ".ctor" : monoMethodName #>
	// Managed return type : <#=WriteFacetTypeInfo(facet)#>
	// Managed param types : <#=WriteFacetTypeInfo(facet.Parameters)#>
    <#=objCMethodType#> (<#=objCTypeDecl#>)<#=objCMethodName#><#=objCMethodParameters#><#=LT#>
<#+		
	if (OutputFileType == OutputType.Implementation) 
	{
		// type warnings
		GenerateTypeWarnings(facet);
		GenerateTypeWarnings(facet.Parameters);
#>
    {
<#+
		if (objCTypeDecl == "void") 
		{
#>
		<#=getExpression#>;
<#+
		} 
		else if (isConstructorMethod) 
		{
#>
		return <#=getExpression#>;
<#+
		} 
		else 
		{
			if (String.IsNullOrEmpty(managedValueToObjC)) throw new Exception("Mono value to ObjC expression is empty"); 
#>
		<#=referencePreProcessBuilder.ToString()#>
		MonoObject *<#=ManagedVariableName#> = <#=getExpression#>
		<#=referencePostProcessBuilder.ToString()#>
		return <#=managedValueToObjC#>;
<#+	
		}// if objCTypeDecl
#>
    }
<#+
	} // if Implementation
}

#>
