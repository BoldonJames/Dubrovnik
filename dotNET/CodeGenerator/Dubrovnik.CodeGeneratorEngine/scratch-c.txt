
<#+
    ////////
    ////////  Write EntityContainer and ObjectContext classes.
    ////////
    foreach (EntityContainer container in GetSourceSchemaTypes<EntityContainer>())
    {
#>

//==================================================================================
// Entity framework model root object
// In .NET this object derives from ObjectContext
//==================================================================================
@<#=outputDelarationPrefix(outputType)#> <#=CW(Code.Escape(container))#><#=outputDelarationSuffix(outputType, "ObjectContext")#>

    // class methods

<#+	// write class setup code
	WriteClassSetup(Code.Escape(container), outputType);
#>

    // <#=   String.Format(CultureInfo.CurrentCulture, GetResourceString("Template_ContextDefaultCtorComment"), container.Name, container.Name)#>
    + (id)entities<#= outputTerminator(outputType)#>
<#+		if (outputType == OutputType.Implementation) 
		{#>
	{
		return [[self alloc] initWithSignature:"" withNumArgs:0, NULL];
	}

<#+		} /* if */ #>
    // <#=   String.Format(CultureInfo.CurrentCulture, GetResourceString("Template_ContextCommonCtorComment"), container.Name)#>
    + (id)entitiesWithString:(NSString *)string<#= outputTerminator(outputType)#>
<#+		if (outputType == OutputType.Implementation) {#>
	{
		return [[self alloc] initWithSignature:"string" withNumArgs:1, [string monoString]]; 
	}

<#+		} /* if */#>
    // <#=   String.Format(CultureInfo.CurrentCulture, GetResourceString("Template_ContextCommonCtorComment"), container.Name)#>
    + (id)entitiesWithConnection:(id) connection<#= outputTerminator(outputType)#>
<#+		if (outputType == OutputType.Implementation) 
		{#>
	{
		[NSException raise:@"Feature not implemented" format:@"none"];
		return nil;
	}

<#+		} /* if */ #>

    //==================================================================================
    // <#=ObjCTypeName("ObjectSet")#> ReadOnly properties
    // In .NET the object returned by these properties derives from ObjectSet<TEntity>
    //==================================================================================

<#+
        ////////
        ////////  Write EntityContainer and ObjectContext ObjectSet properties.
        ////////
        foreach (EntitySet set in container.BaseEntitySets.OfType<EntitySet>())
        {
            VerifyEntityTypeAndSetAccessibilityCompatability(set);

			// output the getter declaration and terminator
			string propertyName = Code.Escape(set);
			string getterName = Char.ToLowerInvariant(propertyName[0]) + propertyName.Substring(1);
			string propertyType = "ObjectSet";
			string setterName = "set" + propertyName;
			string t = outputTerminator(outputType);
			string objCTypeDecl = ObjCTypeDecl("ObjectSet");
			string monoVariableName = "monoObject";
			string itemType = CW(MultiSchemaEscape(set.ElementType, Code));
			string objClassExp = String.Format("[{0} class]", itemType);
			string objCExpression = ObjCExpressionForMonoObject(monoVariableName, propertyType, new List<string> {objClassExp});
#>
    // set of objects of type <#=itemType#>
    - (<#=objCTypeDecl#>)<#=getterName#><#=t#>
<#+			if (outputType == OutputType.Implementation) {#>
    {
        MonoObject *<#=monoVariableName#> = [self getMonoProperty:"<#=propertyName#>"];
		return <#=objCExpression#>;
    }
<#+			} /* if */ #>
 
<#+
        } /* foreach EntitySet */
#>
    } /* foreach EntityContainer */
#>
@end

//==================================================================================
// Model object class defnitions
// In .Net theses classes all derive from EntityObject
//==================================================================================

<#+
    ////////
    ////////  Write EntityObject classes.
    ////////
    foreach (EntityType entity in GetSourceSchemaTypes<EntityType>().OrderBy(e => e.Name))
    {
#>

// Wraps .NET class of type <#=NamespaceName#>.<#=Code.Escape(entity)#>
@<#=outputDelarationPrefix(outputType)#> <#=CW(Code.Escape(entity))#><#=outputDelarationSuffix(outputType, BaseTypeName(entity, Code))#> 

<#+		
		// write class setup code
		WriteClassSetup(Code.Escape(entity), outputType);
#>

    //
    // properties
    // 
<#+
        foreach (EdmProperty property in entity.Properties.Where(p => p.DeclaringType == entity && p.TypeUsage.EdmType is PrimitiveType))
        {
            VerifyGetterAndSetterAccessibilityCompatability(property);
            WritePrimitiveTypeProperty(property, Code, outputType);
        }
#>

    //
    // Navigation properties
    // 
<#+
        ////////
        ////////  Write Navigation Properties.
        ////////
        foreach (NavigationProperty navProperty in entity.NavigationProperties.Where(n => n.DeclaringType == entity))
        {
			// output the getter declaration and terminator
			string propertyName = Code.Escape(navProperty);
			string getterName = Char.ToLowerInvariant(propertyName[0]) + propertyName.Substring(1);
			string setterName = "set" + propertyName;
			string propertyType = CW(MultiSchemaEscape(navProperty.ToEndMember.GetEntityType(), Code));
			string t = outputTerminator(outputType);
			string objCTypeDecl = ObjCTypeDecl("EntityCollection");
			string monoVariableName = "monoObject";
			string objCVariableName = "value";
			string objCExpression = ObjCExpressionForMonoObject(monoVariableName, propertyType);
			string monoExpression = monoExpressionForObjCObject(objCVariableName, objCTypeDecl, propertyType);
#>
	// returns objects of type <#=propertyType#>
    - (<#=objCTypeDecl#>)<#=getterName#><#=t#>
<#+	
			if (outputType == OutputType.Implementation) 
			{
#>	{
		MonoObject *<#=monoVariableName#> = [self getMonoProperty:"<#=propertyName#>"];
		return <#=objCExpression#>;
    }
<#+			} /* if */
			
			// output the setter declaration and terminator 
#>
	- (void)<#=setterName#>:(<#= CW(MultiSchemaEscape(navProperty.ToEndMember.GetEntityType(), Code))#> *)value<#= outputTerminator(outputType)#>
<#+		
			if (outputType == OutputType.Implementation) 
			{
#>	{
		MonoObject *<#=monoVariableName#> = <#=monoExpression#>;
		[self setMonoProperty:"<#=propertyName#>" valueObject:<#=monoVariableName#>];          
    }
<#+			} /* if */
		} /* foreach NavigationProperty */
#>
@end
<#+
    } /* foreach EntityType */
} /* method */



////////
////////  Write PrimitiveType Properties.
////////
private void WritePrimitiveTypeProperty(EdmProperty primitiveProperty, CodeGenerationTools code, OutputType outputType = OutputType.Implementation)
{
    MetadataTools ef = new MetadataTools(this);
	string propertyName = code.Escape(primitiveProperty);
	string getterName = Char.ToLowerInvariant(propertyName[0]) + propertyName.Substring(1);
	string setterName = "set" + propertyName;
	string propertyType = code.Escape(primitiveProperty.TypeUsage);
	string objCTypeDecl = ObjCTypeDecl(propertyType);
	string t = outputTerminator(outputType);

	// create Obj-C representation of mono object
	string monoVariableName = "monoObject";
	string objCVariableName = "value";
	string objCExpression = ObjCExpressionForMonoObject(monoVariableName, propertyType);
	string monoExpression = monoExpressionForObjCObject(objCVariableName, objCTypeDecl, propertyType);
#>

	// wraps property of type <#=propertyType#>
    - (<#=objCTypeDecl#>)<#=getterName#><#=t#>
<#+		
	if (outputType == OutputType.Implementation) 
	{
#>
    {
		MonoObject *<#=monoVariableName#> = [self getMonoProperty:"<#=propertyName#>"];
		return <#=objCExpression#>;
	}
<#+	
	}
#>
    - (void)<#=setterName#>:(<#=ObjCTypeDecl(code.Escape(primitiveProperty.TypeUsage))#>)value<#= outputTerminator(outputType)#>
<#+
	if (outputType == OutputType.Implementation) 
	{
#>
	{
		MonoObject *<#=monoVariableName#> = <#=monoExpression#>;
		[self setMonoProperty:"<#=propertyName#>" valueObject:<#=monoVariableName#>];          
	}
<#+
    }
}
#>

