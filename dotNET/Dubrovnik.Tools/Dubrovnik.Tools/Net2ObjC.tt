
<#@ template language="C#" debug="True" hostspecific="true"#>
<#@ output extension="log" #>
<#@ import namespace="System.Collections"#>
<#@ import namespace="System.Collections.Generic"#>
<#@ import namespace="System.Text"#>
<#@ import namespace="System.Linq"#>
<#@ import namespace="System.Reflection"#>
<#@ import namespace="Dubrovnik.Tools"#>

<#
//     .Net to Objective-C code generator
//
//     This template will generate Objective-C bindings  for each class
//     defined in the input assembly file.
//
//     The wrapper files will generate references to the mono Dubrovnik project to provide
//     access to embedded Mono runtime structures.
//
//      refs:
//      Generating multiple outputs
//      http://www.olegsych.com/2008/03/how-to-generate-multiple-outputs-from-single-t4-template/
//      Dealing with complexity
//      http://msdn.microsoft.com/en-us/magazine/hh975350.aspx
//

// This control block code will be integrated into the TransformText method of Net2ObjC.cs
_TransformText();

#>
<#+
//
// Class feature control blocks.
//

//
//  WriteFileBanner() 
//
void WriteFileBanner() 
{
#>
//------------------------------------------------------------------------------
// <auto-generated tool="<#=GenToolName#>">
//
// <#=OutputFileType == OutputType.Implementation ? ImplementationFile : InterfaceFile #>
//
// Dubrovnik based OS X Cocoa Objective-C to Mono bindings.
//
// This code was generated using a tool available as part of:
// http://github.com/ThesaurusSoftware/Dubrovnik
// This code has dependencies on the above project.
//
// Date:     <#=TimeStamp#>
//
// Assembly: <#=AssemblyFacet.Name#>
// Fullname: <#=AssemblyFacet.FullName#>
// Path:     <#=AssemblyFacet.Path#>
//
// Platform: <#=Environment.OSVersion.VersionString#>
// OS Arch:  <#=Environment.Is64BitOperatingSystem ? "64 bit" : "32 bit"#>
// Process:  <#=Environment.Is64BitProcess ? "64 bit" : "32 bit"#>
// Target:   <#=GetTargetFrameworkVersion()#>
// Runtime:  <#=Environment.Version.ToString()#>
<#+
	// write references info	
	foreach (CodeFacet reference in AssemblyFacet.References)
	{
#>
//
// Asm Ref:  <#=reference.Name#>
// Fullname: <#=reference.FullName#>
<#+
	}
#>
//
// Manual changes to this file may cause unexpected behavior in your application.
// Manual changes to this file will be overwritten if the code is regenerated.
//
// </auto-generated>
//------------------------------------------------------------------------------
<#+
}

//
// WriteModuleBanner
//
public void WriteModuleBanner(CodeFacet facet, string module)
{
	string outputFile = facet.OutputFileName() + OutputFileSuffix();
#>
//++<#=GenToolName#> <#=outputFile#>
//
// Managed <#=module#> : <#=facet.Name#>
//
<#+
	if (OutputFileType == OutputType.Interface)
	{
		string optionalImport = facet.ObjCFacet.Type + ".__Extra__.h";
		string forwardDeclarations = String.Join("\n", ObjCForwardDeclarations(facet));
		string derivationImportDirectives = String.Join("\n", ObjCDerivationImportDirectives(facet));
#>
//
// Optional extra import. Not auto generated. Add manually to project only if required.
//
#if __has_include("<#=optionalImport#>")
#import "<#=optionalImport#>"
#endif

// Frameworks
#import <Cocoa/Cocoa.h>
#import <Dubrovnik/Dubrovnik.h>

// Forward declarations
<#=forwardDeclarations#>

// Import superclass and adopted protocols
<#=derivationImportDirectives#>

<#+
	}
	else 
	{
		string importDirectives = String.Join("\n", ObjCImportDirectives(facet));
#>

// ARC is required
#if  ! __has_feature(objc_arc)
#error This file requires ARC. 
#endif

// Local assembly imports
<#=importDirectives#>

<#+

	}
}

//
// WriteModuleFooter
//
public void WriteModuleFooter()
{
#>
//--<#=GenToolName#>
<#+	
}
//
// WriteInterfaceFilePreliminaries
//
public void WriteInterfaceFilePreliminaries()
{
	string objCAssemblyHeaderName = ObjCIdentifierFromManagedIdentifier(AssemblyFacet.Name);
	string objCAssemblyExtraHeader = objCAssemblyHeaderName + ".__Extra__.h";
	
#>
#import <Cocoa/Cocoa.h>
#import <Dubrovnik/Dubrovnik.h>

//
// Extra include
//
#if __has_include("<#=objCAssemblyExtraHeader#>")
#import "<#=objCAssemblyExtraHeader#>"	// Not auto generated. Add manually to project.
#endif

<#+
	if ( AssemblyFacet.References.Count() > 0) 
	{
#>

//
// Referenced assemblies
//
<#+
    }

	foreach (CodeFacet reference in AssemblyFacet.References)
	{
		string includeFile = reference.Name;
		string defineName = (ObjCIdentifierFromManagedIdentifier(includeFile) + "_Included").ToUpper();
#>
#ifndef <#=defineName#>
//#import "<#=includeFile#>.h"
#endif

<#+  
	}

#>

//
// Class aliases
//
<#+     
	foreach (CodeFacet facet in AssemblyFacet.AllFacets().OrderBy(f => f.Type))
	{
		WriteClassPredeclaration(facet);
	}	
}

static List<string> _classDefines = new List<string>();
//
// WriteClassPredeclaration
//
public void WriteClassPredeclaration(CodeFacet facet)
{
	if (!Config.GenerateTypeBinding(facet)) {
		WriteSkippedItem("type", facet.Description());
		return;
	}

	string namespacePrefix = ObjCAcronymFromManagedIdentifier(facet.TypeNamespace);
	string classDefine = ObjCIdentifierFromManagedIdentifier(namespacePrefix + facet.Name) + "_";
	string classObjCType = facet.ObjCFacet.Type;

   // collision warning facility can be useful but it's loud when it kicks in!
	bool warnAboutCollisions = false;
	if (warnAboutCollisions) {
#>
#ifdef <#=classDefine#>
#warning <#=classDefine#> class name collision.
#else
#define <#=@classDefine#> <#=@classObjCType#>
#endif

<#+	
	} else {

		// issue the define if unique in this scope.
		if (!_classDefines.Contains(classDefine)) {
			_classDefines.Add(classDefine);
#>
#define <#=@classDefine#> <#=@classObjCType#>
<#+
		}
		else {
#>
//#define <#=@classDefine#> <#=@classObjCType#> // WARNING: duplicate detected in file scope
<#+
		}	
	}
}

//
// WritePragmaMark
//
public void WritePragmaMark(string info)
{
#>

#pragma mark -
#pragma mark <#=info#>
<#+	
}

//
// WriteCommentBlock
//
public void WriteCommentBlock(string info)
{
#>

/*

<#=info#>

*/
<#+	
}
//
// WriteImplementationFilePreliminaries
//
public void WriteImplementationFilePreliminaries()
{
	WriteModuleFeatureRequirements();
}

//
// WriteModuleFeatureRequirements
//
public void WriteModuleFeatureRequirements()
{
#>

// ARC is required
#if  ! __has_feature(objc_arc)
#error This file requires ARC. 
#endif

<#+
}

//
// WriteProtocolStart
//
public void WriteProtocolStart(InterfaceFacet facet, string module, bool writeImplementation = false)
{
	if (!writeImplementation) {
		WriteModuleBanner(facet, module);
    }

	string baseProtocol = "System_Object";
	string adoptionProtocolSuffix = "_";
	string adoptionProtocolName = facet.ObjCFacet.Type + adoptionProtocolSuffix;

	if (!writeImplementation) {

		// write adoption protocol
		string protocolSuffix = adoptionProtocolSuffix;
		string protocolName = adoptionProtocolName;
	
		// build list of base protocols 
		string baseProtocols = baseProtocol + protocolSuffix;
		foreach (ImplementedInterfaceFacet interfaceFacet in facet.ImplementedInterfaces) {
			baseProtocols += ", ";
			baseProtocols += (interfaceFacet.ObjCFacet.Type + protocolSuffix);
		}

#>

/*
 A managed interface is represented as follows:

 1. An adoption protocol that advertises that a class has adopted a given protocol. For the reasons 
 given in the notes below this protocol by default declares no members. The code generator will
 use this protocol when declaring classes and method parameters.

 2. An implementation protocol that declares the properties and methods defined by the interface.
 The code generator will use this protocol when declaring variables.

 3. An interface header and implementation body. The explicit class implementation of the managed interface
 can be used to create an instance that conforms to the given interface in order to access explicit properties.

 The above seems to give the best approach for interacting with complex managed interfaces.

 Notes:

 .Net support for explicit interfaces means that a class can inherit two or more different
 signatures for the same property or method from two or more interfaces. 
 This is not supported by Objective-C. 

 A second point is that properties declared in protocols don't get their ivars synthesized.
 This causes warnings to be issued when interface properties are exposed explicitly.

 A third point is that even when we receive a managed interface as a return value from a property 
 or method we still need to provide a full binding in order access those properties and methods.

 A class can test for protocol adoption using Class -conformsToProtocol: using the adoption protocol.
 By casting to the implementation protocol an instance can check for method implementation using respondsToSelector:.

 Properties and method predeclarations can be conditionally included in the adoption protocol if required.

*/


//
// Adoption protocol
//
@protocol <#=protocolName#> <<#=baseProtocols#>>

@optional

#ifdef  DEF_P_AND_M_<#=protocolName.ToUpper()#>
<#+	
    } else {
	
		// write implementation protocol
		string protocolSuffix = "";
		string protocolName = facet.ObjCFacet.Type + protocolSuffix;

		// build list of base protocols 
		string baseProtocols = adoptionProtocolName + ", " + baseProtocol;
		foreach (ImplementedInterfaceFacet interfaceFacet in facet.ImplementedInterfaces) {
			baseProtocols += ", ";
			baseProtocols += (interfaceFacet.ObjCFacet.Type + protocolSuffix);
		}
#>

//
// Implementation protocol
//
@protocol <#=protocolName#> <<#=baseProtocols#>>

@optional

<#+		
	}// if !writeAux

}

//
// WriteProtocolEnd
//
public void WriteProtocolEnd(CodeFacet facet, bool writeAux = false)
{
	if (!writeAux) {
#>
#endif

<#+
    } // if !writeAux
#>

@end

<#+
	if (writeAux) {
		WriteModuleFooter();
    }
}


//
// WriteClassStart
//
public void WriteClassStart(CodeFacet facet, string module, bool writeBanner = true)
{
	// Allocate property name list
	this.StaticObjectPropertyStorageNames = new List<string>();

	// prefix defines interface or implementation
	string classPrefix = OutputDeclarationPrefix();
	string superClass = OutputDeclarationSuffix(facet);
	string implementedProtocols = "";

	// implemented protocol support is available but 
	// we may not be quite ready to supply all the framework managed interfaces that
	// are commonly referenced
	bool outputImplementedProtocols = true;
	if (outputImplementedProtocols) {
		implementedProtocols =  OutputImplementedProtocolSuffix(facet);
    }

	 if (writeBanner) {
		WriteModuleBanner(facet, module);
    }

	 if (facet is EnumerationFacet) {
#>

// C enumeration
<#+
		WriteFacetAsEnumeration((EnumerationFacet)facet);
#>

<#+
	}
#>
@<#=classPrefix#> <#=facet.ObjCFacet.Type#><#=superClass#><#=implementedProtocols#>
<#+	
	WriteClassSetup(facet);	
}


//
// WriteClassSetup
// 
public void WriteClassSetup(CodeFacet facet)
{
	WritePragmaMark("Setup");
#>
	// obligatory override
	+ (const char *)monoClassName<#=LT#>
<#+
	if (OutputFileType == OutputType.Implementation) 
	{
		string name = CodeFacet.NormalizeGenericTypesInManagedIdentifier(facet.NameFromType);
#>
	{
		return "<#=facet.TypeNamespace#>.<#=name#>";
	}
<#+
    }
#>
	// obligatory override
	+ (const char *)monoAssemblyName<#=LT#>
<#+	
	if (OutputFileType == OutputType.Implementation) 
	{
#>
	{
		return "<#=AssemblyFacet.Name#>";
	}
<#+
    }
}

//
// WriteClassEnd
//
public void WriteClassEnd(CodeFacet facet)
{
	WriteClassTeardown(facet);	
#>
@end
<#+
	WriteModuleFooter();
}

//
// WriteClassTeardown
// 
public void WriteClassTeardown(CodeFacet facet)
{
	if (OutputFileType == OutputType.Implementation) 
	{
	WritePragmaMark("Teardown");
#>
	- (void)dealloc
	{
<#+
		foreach (string staticObjectPropertyName in StaticObjectPropertyStorageNames)
        {
#>
		<#=staticObjectPropertyName#> = nil;
<#+
        }
#>
	}
<#+

	this.StaticObjectPropertyStorageNames = null;
    }
}
//
// WriteFacetAsEnumeration
//
public void WriteFacetAsEnumeration(EnumerationFacet enumeration)
{
	string objCEnumType = ObjCTypeNameFromManagedTypeName(enumeration.UnderlyingType);
	string objCType = ObjCTypeNameFromManagedTypeName(enumeration.Type);

	// output the enums as a C typedef enum.
	if (OutputFileType == OutputType.Interface) 
	{
#>
typedef NS_ENUM(<#=objCEnumType#>, enum<#=objCType#>) {
<#+
		foreach (FieldFacet field in enumeration.Fields) {
			string objCFieldName = ObjCIdentifierFromManagedIdentifier(field.Name);
#>
	<#=objCType#>_<#=objCFieldName#> = <#=field.ConstantValue#>,
<#+
		}
#>
};
<#+
    } 

}

//
// WriteFacetAsAccessor
// 
public void WriteFacetAsAccessor(CodeFacet facet, Dictionary<string, object> options = null)
{
	// define getters and setters
	string accessorName = facet.Name;
	string accessorDescription = facet is PropertyFacet ? "property" : "field";
	string getterName = accessorName.FirstCharacterToLower();
	string setterName = "set" + accessorName.FirstCharacterToUpper();
	string accessorType = facet.Type;
	string objCTypeDecl = ObjCTypeDeclFromManagedFacet(facet);
	bool isObjectProperty = ObjCRepresentationIsObject(facet);
	string monoObjectPtr = "MonoObject *";
	
	// some NSObject properties need a bit of TLC
	List<string> baseProperties = new List<string> {"description"};

	// property storage and evaluation
	string propertyAttributes = "";
	string propertyStorage = "_" + getterName;
	if (facet.IsStatic) {
		propertyStorage = "m" + propertyStorage;
		if (isObjectProperty) 
        {
			this.StaticObjectPropertyStorageNames.Add(propertyStorage);
        }
    }
	string doPropertyEqualityTest = "";
	if (isObjectProperty) {
		// test if mono object pointer and property storage reference the same managed object
		doPropertyEqualityTest = string.Format("if ([self object:{0} isEqualToMonoObject:{1}]) return {0};", propertyStorage, ManagedVariableName);
   }

	// instance property.
	if (!facet.IsStatic) {
		string attributes = "nonatomic";

		// object property attributes
		if (ObjCRepresentationIsObject(facet)) {
			attributes += ", strong";
		}
		if (!facet.IsWritable) {
			attributes += ", readonly";
		} 
		propertyAttributes =  String.Format("({0}) ", attributes);
    }

	// create Obj-C representation of managed object
	string managedValueToObjC = ManagedValueToObjc(ManagedVariableName, facet);
	string objCValueToMono = ObjCValueToManaged(ObjCVariableName, objCTypeDecl, facet);
	ObjCTypeAssociation objCTypeAssociate = ObjCTypeAssociate(facet);
	string objCMethodType = !facet.IsStatic ? "-" : "+";

	// form mono method invocation name.
	// a prefix may be required, for instance when calling explicit interface properties.
	string monoMethodPrefix = "";
	if (options != null) {
		if (options.ContainsKey("cAPIMethodPrefix")) {
			monoMethodPrefix = (string)options["cAPIMethodPrefix"];
        }
    }
	string monoInvocationName = monoMethodPrefix + accessorName;

	// Info comment
#>

	// Managed <#=accessorDescription#> name : <#=accessorName#>
	// Managed <#=accessorDescription#> type : <#=WriteFacetTypeInfo(facet)#>
<#+	
	// Interface 
	if (OutputFileType == OutputType.Interface) 
	{
		// instance property
		if (!facet.IsStatic) 
		{
			// avoid overriding NSObject properties as we may generate an attribute mismmatch and
			// trigger a storm of warnings
			string prefix = "";
			if (baseProperties.Contains(getterName)) {
				prefix = "// Avoid potential property attribute clash // ";
			}
#>
    <#=prefix#>@property <#=propertyAttributes#><#=objCTypeDecl#> <#=getterName#>;
<#+	  
			return;
        }    
	} 
	else 
	{
		// implementation

		// instance property
		if (!facet.IsStatic) 
		{
			// synthesize ivar property storage
#>
    @synthesize <#=getterName#> = <#=propertyStorage#>;
<#+		
		} else { // declare static property storage
#>
    static <#=objCTypeDecl#> <#=propertyStorage#>;
<#+      
		}
    }

	//
	// write getter method
	//
	if (facet.IsReadable) 
	{
#>
    <#=objCMethodType#> (<#=objCTypeDecl#>)<#=getterName#><#=LT#>
<#+		
		if (OutputFileType == OutputType.Implementation) 
		{
			if (facet is PropertyFacet) { 
				// thunking : primitive value types and enumerations are returned by value.
				// other value types, such as DateTime are returned as boxed values
				string thunkTypeDecl = null;
				if (ObjCRepresentationIsPrimitive(facet)) {
					managedValueToObjC = "monoObject";
					thunkTypeDecl = objCTypeDecl;
				} else {
					thunkTypeDecl = "MonoObject *";
				}

				// note that the thunk is valid only for a specific class instance.
				// if the obj-C receiver represents a managed interface then the cached thunk
				// must be regenerated if the thunk id invalid for the receiver mono class.
				if (!facet.IsStatic) {
#>
    {
		typedef <#=thunkTypeDecl#> (*Thunk)(MonoObject *, MonoObject**);
		static Thunk thunk;
		static MonoClass *thunkClass;
		MonoObject *monoException = NULL;
		if (!thunk || thunkClass != self.monoClass) {
			thunkClass = self.monoClass;
			MonoMethod *monoMethod = GetPropertyGetMethod(thunkClass, "<#=monoInvocationName#>");
			thunk = (Thunk)mono_method_get_unmanaged_thunk(monoMethod);
		}
		<#=thunkTypeDecl#> monoObject = thunk(self.monoObject, &monoException);
		if (monoException != NULL) @throw(NSExceptionFromMonoException(monoException, @{}));
<#+
				} // end non static property
				else 
				{ // static property
#>
    {
		typedef <#=thunkTypeDecl#> (*Thunk)(MonoObject**);
		static Thunk thunk;
		static MonoClass *thunkClass;
		MonoObject *monoException = NULL;
		if (!thunk || thunkClass != self.monoClass) {
			thunkClass = self.monoClass;
			MonoMethod *monoMethod = GetPropertyGetMethod(thunkClass, "<#=monoInvocationName#>");
			thunk = (Thunk)mono_method_get_unmanaged_thunk(monoMethod);
		}
		<#=thunkTypeDecl#> monoObject = thunk(&monoException);
		if (monoException != NULL) @throw(NSExceptionFromMonoException(monoException, @{}));
<#+
				} // end static property
			} // end thunking property
			else 
			{  // field 
				string getFormat;
				if (!facet.IsStatic) {
					getFormat = "[self getMonoField:\"{0}\"]";
				} else {
					getFormat = "[[self class] getMonoClassField:\"{0}\"]";
				}
				string getExpression = String.Format(getFormat, monoInvocationName);
#>
    {
		<#=monoObjectPtr#><#=ManagedVariableName#> = <#=getExpression#>;
<#+	
			} // end field 

			if (isObjectProperty) // object equality test
			{
#>
		<#=doPropertyEqualityTest#>					
<#+	
			} // end object equality test
#>
		<#=propertyStorage#> = <#=managedValueToObjC#>;

		return <#=propertyStorage#>;
	}
<#+	
		} // end implementation
   } // end isReadable

	//
	// write setter method
	//
	if (facet.IsWritable) 
	{

#>
    <#=objCMethodType#> (void)<#=setterName#>:(<#=objCTypeDecl#>)<#=ObjCVariableName#><#=LT#>
<#+
		if (OutputFileType == OutputType.Implementation) 
		{
			//
			// Property setter
			//
			if (facet is PropertyFacet) {
				string thunkArgTypeDecl, thunkArg;
				if (ObjCRepresentationIsPrimitive(facet)) {
					thunkArgTypeDecl = objCTypeDecl;
					thunkArg = ObjCVariableName;
				} else {
					thunkArgTypeDecl = "MonoObject *";
					thunkArg = string.Format("[{0} monoObject]", ObjCVariableName);
				} 
				if (!facet.IsStatic) {
#>
	{
		<#=propertyStorage#> = <#=ObjCVariableName#>;
		typedef void (*Thunk)(MonoObject *, <#=thunkArgTypeDecl#>, MonoObject**);
		static Thunk thunk;
		static MonoClass *thunkClass;
		if (!thunk || thunkClass != self.monoClass) {
			thunkClass = self.monoClass;
			MonoMethod *monoMethod = GetPropertySetMethod(thunkClass, "<#=monoInvocationName#>");
			thunk = (Thunk)mono_method_get_unmanaged_thunk(monoMethod);
		}
		MonoObject *monoException = NULL;
		thunk(self.monoObject, <#=thunkArg#>, &monoException);
		if (monoException != NULL) @throw(NSExceptionFromMonoException(monoException, @{}));
	}
<#+
				} // end non static
				else 
				{ // static
#>
	{
		<#=propertyStorage#> = <#=ObjCVariableName#>;
		typedef void (*Thunk)(<#=thunkArgTypeDecl#>, MonoObject**);
		static Thunk thunk;
		static MonoClass *thunkClass;
		if (!thunk || thunkClass != self.monoClass) {
			thunkClass = self.monoClass;
			MonoMethod *monoMethod = GetPropertySetMethod(thunkClass, "<#=monoInvocationName#>");
			thunk = (Thunk)mono_method_get_unmanaged_thunk(monoMethod);
		}
		MonoObject *monoException = NULL;
		thunk(<#=thunkArg#>, &monoException);
		if (monoException != NULL) @throw(NSExceptionFromMonoException(monoException, @{}));
	}
<#+
				} // end static
			} // end property 
			else 
			{ 
				//
				// field setter
				//
				string setFormat;
				if (!facet.IsStatic) {
					setFormat = "[self setMonoField:\"{0}\" valueObject:{1}]";
				} else {
					setFormat = "[[self class] setMonoClassField:\"{0}\" valueObject:{1}]";
				}
				string setExpression = String.Format(setFormat, monoInvocationName, ManagedVariableName);
#>
	{
		<#=propertyStorage#> = <#=ObjCVariableName#>;
		<#=monoObjectPtr#><#=ManagedVariableName#> = <#=objCValueToMono#>;
		<#=setExpression#>;          
	}
<#+
			} // end field
		}  // end Implementation
	} // end IsWritable
}

//
// WriteFacetAsMethod
//
public void WriteFacetAsMethod(MethodFacet facet, Dictionary<string, object> options = null)
{
	// In order to ensure compilation of an assembly and its references 
	// the generated code must resolve all types.
	//
	// The generation of a complete set of methods is obviously desirable
	// but in some cases may not be achievable if a unique method signature 
	// cannot be obtained. 

	// if the method is a duplicate (ie: name, parameter types, return type) 
	// then we have no option but to omit it
	if (facet.IsDuplicateSignatureMethod) 
	{
		this.Warning("Duplicate method omitted : " + facet.Name);
		return;
	}

	// if the facet is overloaded on its signature and differs only in its
	// return type then omit it.
	// This can occur with explicit operators.
	// At present it is unknown if these can be called via the embedded API.
	if (facet.IsOverloadedSignatureMethod) 
	{
		this.Warning("Overloaded signature method omitted : " + facet.Name);
		return;
    }

	string objCMethodInvokeFormat = null;
	string objCMethodPrepareFormat = null;
	bool isConstructorMethod = (facet.Name == null);	// constructor has no method name
	string objCMethodType = null;

	// Method name. We do some rudimentary processing to prevent troublesome behaviour.
	// We may have to prefix certian method names to conform to ARC's semantics
	// see https://stackoverflow.com/questions/22529454/simple-rules-for-naming-methods-compatible-with-arc-naming-conventions
	string monoMethodName = facet.Name;
	string objCMethodName = monoMethodName.FirstCharacterToLower();
	List<string> unsafeObjCMethodNames = null;
	List<string> unsafeObjCInitMethodNamesStartingWith = null;
	if (facet.IsStatic || isConstructorMethod) 
	{
		objCMethodType = "+";
		if (facet.Parameters.Count == 0) 
		{
			unsafeObjCMethodNames = new List<string> {
												"load",	// +load will get called when the unmanaged framework loads. The managed code will likely not expect this.
												"initialize",	
												"alloc",
												"new",
												"class",
												"superclass"
											};
		}
	}
	else 
	{
		unsafeObjCInitMethodNamesStartingWith = new List<string> {
												"init" 
		};
		objCMethodType = "-";
	}
	if (unsafeObjCMethodNames != null && unsafeObjCMethodNames.Contains(objCMethodName))
	{
		objCMethodName += "_";
	}

	// methods beginning with init are expected to return a type related to the receiver
	if (unsafeObjCInitMethodNamesStartingWith != null && 
		facet.Type != "System.Void" &&
		unsafeObjCInitMethodNamesStartingWith.Any(p => objCMethodName.StartsWith(p, false, null)))
	{
			objCMethodName = "db_" + objCMethodName;
	}

	// return type
	string objCTypeDecl = ObjCTypeDeclFromManagedFacet(facet);
	if (facet.IsInterface) 
	{
		objCTypeDecl = ObjCConformingTypeFromObjCTypeDecl(objCTypeDecl, true);
	}

	string managedValueToObjC = null;

	// instance method requires a name and type
	if (!isConstructorMethod) 
	{
		// create Obj-C representation of mono object
		managedValueToObjC = ManagedValueToObjc(ManagedVariableName, facet);

		if (!facet.IsStatic) 
		{
			if (!facet.IsGenericMethodDefinition) {
				objCMethodInvokeFormat = "[self invokeMonoMethod:\"{0}({1})\" withNumArgs:{2}]";
			}
			else
			{
				objCMethodPrepareFormat = "DBManagedMethod *managedMethod = [[DBGenericTypeHelper sharedHelper] methodWithMonoMethodNamed:\"{0}({1})\" typeParameters:typeParameter]";
				objCMethodInvokeFormat = "[self invokeMethod:managedMethod withNumArgs:{2}]";
			}
		} 
		else 
		{
			objCMethodInvokeFormat = "[self invokeMonoClassMethod:\"{0}({1})\" withNumArgs:{2}]";
		}
	}
	else 
	{
		// this looks like a default constructor
		if (facet.Parameters.Count() == 0) 
		{
			return;
		}

		objCMethodName = "new";

		// a constructor requires no explicit name or type
		objCMethodInvokeFormat = "[[self alloc] initWithSignature:\"{1}\" withNumArgs:{2}]";
    }

	// build the parameters
	StringBuilder monoSigBuilder = new StringBuilder();
	StringBuilder objCParameterBuilder = new StringBuilder();
	StringBuilder invokeArgsBuilder = new StringBuilder();
	StringBuilder referencePreProcessBuilder = new StringBuilder();
	StringBuilder referencePostProcessBuilder = new StringBuilder();

	int idx = 0;
	foreach (ParameterFacet parameter in facet.Parameters) 
	{

		// if the mono parameters is passed by ref then strip
		// the suffix to enable type association
		string monoParameterType = parameter.Type;
		if (parameter.IsByRef || parameter.IsPointer) 
		{
			monoParameterType = parameter.ElementType;
      }

		//
		// build the ObjC method interleaved parameter representation
		// eg: name1:(int32_t)p1 name2:(int64_t)p2 name3:(NSString *)p3
		//
		string objCParamTypeDecl = null;
		bool objCParameterIsObject = true;

		//
		// Get the ObjC type associated with the parameter.
		//
		ObjCTypeAssociation objCTypeAssociate = ObjCTypeAssociate(parameter);
		ManagedTypeAssociation managedTypeAssociate = null;
		if (objCTypeAssociate != null) 
		{
			//
			// If the parameter is an array, say Int64[], then its Obj-C rep will be System.Array
			// The mono type association however must reflect the represented type, Int64.
			//
			if (parameter.IsArray) 
			{
				ObjCTypeAssociation objCRepresentedTypeAssociate = ObjCTypeAssociate(parameter.ElementType);
				if (objCRepresentedTypeAssociate != null) 
				{
					managedTypeAssociate = objCRepresentedTypeAssociate.ManagedTypeAssociate;
                }
			}
			
			if (managedTypeAssociate == null) 
			{
				managedTypeAssociate = objCTypeAssociate.ManagedTypeAssociate;
			}

			objCParamTypeDecl =  objCTypeAssociate.ObjCTypeDecl;
			objCParameterIsObject = objCTypeAssociate.IsNSObject;
		} 
		else 
		{
			//
			// Generate default objC representations
			//
			objCParamTypeDecl = ObjCTypeDeclFromManagedFacet(parameter);
			objCParameterIsObject = ObjCRepresentationIsObject(parameter);
        }

		// if parameter is an interface then use adoption conforming type ie: id <typename>
		if (parameter.IsInterface) {
			objCParamTypeDecl = ObjCConformingTypeFromObjCTypeDecl(objCParamTypeDecl, false);
		}
		if (parameter.IsByRef || parameter.IsPointer) 
		{
			objCParamTypeDecl += "*";	// add additional indirection
		}

		//
		// Build the mono method argument invocation signature
		//
		if (idx > 0) monoSigBuilder.Append(",");
		string monoParameterTypeInvoke = null;
 
		// if type is a GenericParameter defined by the class, as opposed to via a method like so Method<T>(T).
		// in this case we want to identify the parameter by its position as this makes it simple
		// to build the required signature at run time
		if (parameter.IsGenericParameter && !parameter.DeclaredByMethod) {

			// generic parameters must have an associate
			if (managedTypeAssociate == null) 
			{
				throw new Exception("Missing managed type association for generic parameter."); 
			}

			monoParameterTypeInvoke = managedTypeAssociate.ManagedTypeInvoke;
			if (parameter.IsArray)  
			{
				monoParameterTypeInvoke += "[]";
         }
			
			// in order for the C api to substitute the correct type at run time
			// the generic parameter position needs to be indicated.
			monoParameterTypeInvoke = string.Format(monoParameterTypeInvoke, parameter.GenericParameterPosition);
		}
		
		// if parameter is declared by the method like so Method<T>(T) then we want to preserve the type name
		// as this constitutes part of the method signature this is used to lookup the generic method for inflation
		else if (parameter.IsGenericParameter && parameter.DeclaredByMethod) 
		{ 	
			// we expect to be opertaing on a generic method definition
		   if (!facet.IsGenericMethodDefinition) 
			{
				throw new Exception("Generic method definition expected."); 
			}

			// the type sig will be something like Declaring.Type+T but the embedded API sig
			// uses just the type parameter name T
			int symbolIndex = monoParameterType.IndexOf('+');
			if (symbolIndex == -1) {
				throw new Exception("Missing nested type symbol for generic parameter."); 
			}
			monoParameterTypeInvoke = monoParameterType.Substring(symbolIndex + 1);
			if (parameter.IsArray)  
			{
				monoParameterTypeInvoke += "[]";
         }
		} 
	   else 
		{
			monoParameterTypeInvoke = ManagedTypeInvokeFromManagedType(monoParameterType);
		}

		// Note that we use a separate variable to hold the actual type sig used in the in mono_method_desc call
		// as the signature may need to be specfically modified for the mono_method_desc API.
		string monoParameterTypeInvoke_ = monoParameterTypeInvoke;

		// The mono_method_desc * APIs prefix nested classes with a '/' rather than a '+' to conform with IL/CTS conventions
		// The approach used here is trivial and is likely fragile.
		// We probably need a separate mono param type builder like that found in debug-helpers.c append_class_name().
		// Note that Delegates will present as nested classes.
		// Also note that although we have an IsNested property we shouldn't use it as a conditional test for this operation
		// as generic types with nested type paramaters such as System.Collections.Generic.IEnumerable`1<A.B+C>
		// won't identify as nested.
		monoParameterTypeInvoke_ = monoParameterTypeInvoke_.Replace("+", "/");

		// add type signature and access modifier
		monoSigBuilder.Append(monoParameterTypeInvoke_);
		if (parameter.IsPointer) 
		{
			monoSigBuilder.Append("*");
		}
		if (parameter.IsByRef) 
		{
			monoSigBuilder.Append("&");	// the signature needs to express by ref
      }

		// Build ObjC parameter name.
		// In order to represent overloaded methods effectively the 
		// ObjC paramter name is constructed as follows:
		// Managed parameter name + Managed parameter type + Ref
		string objCParamName = ObjCIdentifierFromManagedIdentifier(parameter.Name);
		
		// If the method is overloaded by parameter then make the ObjC method
		// name unique by including type info in the name.
		//
		// Managed methods are overloaded by name only.
		// The Obj-C metjods representation uses interleaved parameters which may
		// be sufficient to produce a unique method signature.
		//
		// If however a managed method overload differs only in the type of its parameters 
		// (the managed method name, parameter count and parameter names all being equal)
		// then the Obj-C interleaved parameters will include type info.
		string objCParamOverloadSuffix = "";
		if (facet.IsOverloadedParameterMethod) 
		{
			// We adopt a minimal as opposed to a full type repesentation here in order
			// to minimize the parameter length.
			// Time will tell how it flies.
			objCParamOverloadSuffix = ObjCMinimalIdentifierFromManagedIdentifier(monoParameterTypeInvoke);
      }
		if (parameter.IsByRef) 
		{
			objCParamOverloadSuffix += "Ref";
        }
		if (objCParamOverloadSuffix.Length > 0) 
		{
			objCParamName += objCParamOverloadSuffix.FirstCharacterToUpper();
        }

		// append the complete interleaved parameter expression
		if (idx == 0) 
		{
			if (AppendFirstArgSignatureToMethodName) 
			{
				// the leading underscore helps identify the preceding characters as the managed method name
				objCMethodName += "_with";
				objCParameterBuilder.AppendFormat("{0}", objCParamName.FirstCharacterToUpper());
            } 
        } 
		else 
		{
			objCParameterBuilder.AppendFormat(" {0}", objCParamName.FirstCharacterToLower());
        }
		objCParameterBuilder.AppendFormat(":({0})p{1}", objCParamTypeDecl, idx + 1);

		//
		// build the mono invocation argument representation
		// eg: DB_VALUE(p1), DB_VALUE(p2), [p3 monoRTInvokeArg]
		//
		string argFormat = null;
		if (idx > 0) invokeArgsBuilder.Append(", ");
		if (objCParameterIsObject) 
		{
			if (parameter.IsByRef) {
				argFormat = "&refPtr{0}";	// use reference pointer
            } else {
				argFormat = "[p{0} monoRTInvokeArg]";
            }
        } 
		else 
		{
			if (parameter.IsByRef || parameter.IsPointer) 
			{
				argFormat = "p{0}";	// just pass the pointer
            } 
			else 
			{
				argFormat = "DB_VALUE(p{0})";	// DB_VALUE equates to &
            }
		}
		invokeArgsBuilder.AppendFormat(argFormat, idx + 1);

		//
		// Build reference parameter pre and post process assignment statements
		//
		// Reference parameters need to be assigned to temporary variables
		// to allow for their mutation
		//
		if (objCParameterIsObject && parameter.IsByRef) {

			// dereference and assign temporary variable
			string preProcess = string.Format("void *refPtr{0} = [*p{0} monoRTInvokeArg];{1}", idx + 1, Environment.NewLine);
			referencePreProcessBuilder.Append(preProcess);

			// create new object subclass for reference 
			string postProcess = string.Format("*p{0} = [System_Object bestObjectWithMonoObject:refPtr{0}];{1}", idx + 1, Environment.NewLine);
			referencePostProcessBuilder.Append(postProcess);
		}

		idx++;
	}

	// a generic method definition will require an additional parameter to specify the generic type parameters
	if (facet.IsGenericMethodDefinition)
	{
		// get number of generic type arameters defined by the generic method definition as opposed to by the type defining the method
	   int numberOfTypeParametersDeclaredByMethod = facet.GenericMethodDefinitionGenericTypeArguments.Count();
	   string parameterSig = "typeParameter:(id)typeParameter";
		if (numberOfTypeParametersDeclaredByMethod > 1) 
		{
			parameterSig = "typeParameters:(NSArray<id> *)typeParameter";
		}
		if (facet.Parameters.Count() == 0)
		{
			objCMethodName += "_with";
			objCParameterBuilder.AppendFormat("{0}", parameterSig.FirstCharacterToUpper());
		}
		else 
		{
			objCParameterBuilder.AppendFormat(" {0}", parameterSig);
		}
	}

	// finalize argument list representations
	string monoMethodSig = monoSigBuilder.ToString();
	string objCMethodParameters = objCParameterBuilder.ToString();
	string invokeArgs = facet.Parameters.Count().ToString();
	if (facet.Parameters.Count() > 0) 
	{
		invokeArgs += ", " + invokeArgsBuilder.ToString();
   }

	// form mono method invocation name.
	// a prefix may be required, for instance when calling explicit interface methods.
	string monoMethodPrefix = "";
	if (options != null) {
		if (options.ContainsKey("cAPIMethodPrefix")) {
			monoMethodPrefix = (string)options["cAPIMethodPrefix"];
        }
    }
	string monoInvocationName = monoMethodPrefix + monoMethodName;

	// we may have an expression that prepares the get expression method argument
	if (objCMethodPrepareFormat != null) {
		string expression = String.Format(objCMethodPrepareFormat, monoInvocationName, monoMethodSig, invokeArgs) + ";";
		referencePreProcessBuilder.AppendFormat("{0}{1}", expression, Environment.NewLine);
	}

	// the get expression invokes the method and gets the result
	string getExpression = String.Format(objCMethodInvokeFormat, monoInvocationName, monoMethodSig, invokeArgs) + ";";
	if (referencePostProcessBuilder.Length > 0) {
		getExpression += Environment.NewLine;
    }

	// validation
	if (isConstructorMethod && String.IsNullOrEmpty(monoMethodSig)) throw new Exception("Mono method argument signature is empty");
	if (String.IsNullOrEmpty(objCTypeDecl)) throw new Exception("ObjC type Declaration is empty");    
	if (String.IsNullOrEmpty(objCMethodName)) throw new Exception("Method name is empty"); 
	if (String.IsNullOrEmpty(getExpression)) throw new Exception("Get expression is empty"); 

	//
	// write method
	//
#>

	/*! 
		Managed method name : <#=isConstructorMethod ? ".ctor" : monoMethodName #>
		Managed return type : <#=WriteFacetTypeInfo(facet)#>
		Managed param types : <#=WriteFacetTypeInfo(facet.Parameters)#>
<#+
	if (facet.IsGenericMethodDefinition) 
	{
#>
		Generic method definition type params : <#=WriteFacetTypeInfo(facet.GenericMethodDefinitionGenericTypeArguments)#>
<#+
	}
#>
	 */
    <#=objCMethodType#> (<#=objCTypeDecl#>)<#=objCMethodName#><#=objCMethodParameters#><#=LT#>
<#+		
	if (OutputFileType == OutputType.Implementation) 
	{
		// type warnings
		GenerateTypeWarnings(facet);
		GenerateTypeWarnings(facet.Parameters);
#>
    {
<#+
		if (objCTypeDecl == "void") 
		{
#>
		<#=referencePreProcessBuilder.ToString()#>
		<#=getExpression#>
      <#=referencePostProcessBuilder.ToString()#>
<#+
		} 
		else if (isConstructorMethod) 
		{
#>
		<#=referencePreProcessBuilder.ToString()#>
		<#=objCTypeDecl#> object = <#=getExpression#>
      <#=referencePostProcessBuilder.ToString()#>
      return object;
<#+
		} 
		else 
		{
			if (String.IsNullOrEmpty(managedValueToObjC)) throw new Exception("Mono value to ObjC expression is empty"); 
#>
		<#=referencePreProcessBuilder.ToString()#>
		MonoObject *<#=ManagedVariableName#> = <#=getExpression#>
		<#=referencePostProcessBuilder.ToString()#>
		return <#=managedValueToObjC#>;
<#+	
		}// if objCTypeDecl
#>
    }
<#+
	} // if Implementation
}

#>
