
<#@ template language="C#" debug="True" hostspecific="true"#>
<#@ output extension="log" #>
<#@ import namespace="System.Collections"#>
<#@ import namespace="System.Collections.Generic"#>
<#@ import namespace="System.Text"#>
<#@ import namespace="System.Linq"#>
<#@ import namespace="System.Reflection"#>
<#@ import namespace="Dubrovnik.Tools"#>
<#@ import namespace="Dubrovnik.Tools.Facets"#>

<#
//     .Net to Objective-C code generator
//
//     This template will generate Objective-C bindings  for each class
//     defined in the input assembly file.
//
//     The wrapper files will generate references to the mono Dubrovnik project to provide
//     access to embedded Mono runtime structures.
//
//      refs:
//      Generating multiple outputs
//      http://www.olegsych.com/2008/03/how-to-generate-multiple-outputs-from-single-t4-template/
//      Dealing with complexity
//      http://msdn.microsoft.com/en-us/magazine/hh975350.aspx
//

// This control block code will be integrated into the TransformText method of Net2ObjC.cs
_TransformText();

#>
<#+
//
// Class feature control blocks.
//

//
//  WriteFileBanner() 
//
void WriteFileBanner() 
{
#>
//------------------------------------------------------------------------------
// <auto-generated tool="<#=GenToolName#>">
//
// <#=OutputFileType == OutputType.Implementation ? ImplementationFile : InterfaceFile #>
//
// Dubrovnik based OS X Cocoa Objective-C to Mono bindings.
//
// This code was generated using a tool available as part of:
// http://github.com/ThesaurusSoftware/Dubrovnik
// This code has dependencies on the above project.
//
// Date:     <#=TimeStamp#>
//
// Assembly: <#=AssemblyFacet.Name#>
// Fullname: <#=AssemblyFacet.FullName#>
// Path:     <#=AssemblyFacet.Path#>
//
// Platform: <#=Environment.OSVersion.VersionString#>
// OS Arch:  <#=Environment.Is64BitOperatingSystem ? "64 bit" : "32 bit"#>
// Process:  <#=Environment.Is64BitProcess ? "64 bit" : "32 bit"#>
// Target:   <#=GetTargetFrameworkVersion()#>
// Runtime:  <#=Environment.Version.ToString()#>
<#+
	// write references info	
	foreach (CodeFacet reference in AssemblyFacet.References)
	{
#>
//
// Asm Ref:  <#=reference.Name#>
// Fullname: <#=reference.FullName#>
<#+
	}
#>
//
// Manual changes to this file may cause unexpected behavior in your application.
// Manual changes to this file will be overwritten if the code is regenerated.
//
// </auto-generated>
//------------------------------------------------------------------------------
<#+
}

//
// WriteModuleBanner
//
public void WriteModuleBanner(CodeFacet facet, string module)
{
	string outputFile = facet.OutputFileName() + OutputFileSuffix();
#>
//++<#=GenToolName#> <#=outputFile#>
//
// Managed <#=module#> : <#=facet.Name#>
//
<#+
	if (OutputFileType == OutputType.Interface)
	{
		// ObjC interface
		string optionalImport = facet.ObjCFacet.Type + ".__Extra__.h";
		List<string> declarations =  ObjCForwardDeclarations(facet);
		string forwardDeclarations = String.Join("\n", declarations);
		string derivationImportDirectives = String.Join("\n", ObjCDerivationImportDirectives(facet));
#>
//
// Frameworks
//
#import <Cocoa/Cocoa.h>
#import <Dubrovnik/Dubrovnik.h>

//
// Optional extra import. Not auto generated. Add manually to project only if required.
//
#if __has_include("<#=optionalImport#>")
#import "<#=optionalImport#>"
#endif

//
// Forward class and protocol declarations
//
<#=forwardDeclarations#>

//
// Import superclass and adopted protocols
//
<#=derivationImportDirectives#>

<#+
	}
	else 
	{
		string optionalImport = ObjCAssemblyName + ".private.h";
#>

// ARC is required
#if  ! __has_feature(objc_arc)
#error This file requires ARC. 
#endif

// Local assembly import
#import "<#=InterfaceFile#>"

#if __has_include("<#=optionalImport#>")
#import "<#=optionalImport#>"    // Not auto generated. Add manually to project.
#endif

<#+
	}
}

//
// WriteModuleFooter
//
public void WriteModuleFooter()
{
#>
//--<#=GenToolName#>
<#+	
}
//
// WriteInterfaceFilePreliminaries
//
public void WriteInterfaceFilePreliminaries()
{
	string objCAssemblyHeaderName = ObjCIdentifierFromManagedIdentifier(AssemblyFacet.Name);
	string objCAssemblyExtraHeader = objCAssemblyHeaderName + ".__Extra__.h";
	
#>
#import <Cocoa/Cocoa.h>
#import <Dubrovnik/Dubrovnik.h>

//
// Extra include
//
#if __has_include("<#=objCAssemblyExtraHeader#>")
#import "<#=objCAssemblyExtraHeader#>"	// Not auto generated. Add manually to project.
#endif

<#+
	if ( AssemblyFacet.References.Count() > 0) 
	{
#>

//
// Referenced assemblies
//
<#+
    }

	foreach (CodeFacet reference in AssemblyFacet.References)
	{
		string includeFile = reference.Name;
		string defineName = (ObjCIdentifierFromManagedIdentifier(includeFile) + "_Included").ToUpper();
#>
#ifndef <#=defineName#>
//#import "<#=includeFile#>.h"
#endif

<#+  
	}

#>

//
// Class aliases
//
<#+     
	foreach (CodeFacet facet in AssemblyFacet.AllFacets().OrderBy(f => f.Type))
	{
		WriteClassPredeclaration(facet);
	}	
}

static List<string> _classDefines = new List<string>();
//
// WriteClassPredeclaration
//
public void WriteClassPredeclaration(CodeFacet facet)
{
	if (!Config.GenerateFacetBinding(facet)) {
		WriteSkippedItem("type", facet.Description());
		return;
	}

	string namespacePrefix = ObjCAcronymFromManagedIdentifier(facet.TypeNamespace);
	string classDefine = ObjCIdentifierFromManagedIdentifier(namespacePrefix + facet.Name) + "_";
	string classObjCType = facet.ObjCFacet.Type;

   // collision warning facility can be useful but it's loud when it kicks in!
	bool warnAboutCollisions = false;
	if (warnAboutCollisions) {
#>
#ifdef <#=classDefine#>
#warning <#=classDefine#> class name collision.
#else
#define <#=@classDefine#> <#=@classObjCType#>
#endif

<#+	
	} else {

		// issue the define if unique in this scope.
		if (!_classDefines.Contains(classDefine)) {
			_classDefines.Add(classDefine);
#>
#define <#=@classDefine#> <#=@classObjCType#>
<#+
		}
		else {
#>
//#define <#=@classDefine#> <#=@classObjCType#> // WARNING: duplicate detected in file scope
<#+
		}	
	}
}

//
// WritePragmaMark
//
public void WritePragmaMark(string info)
{
#>

#pragma mark -
#pragma mark <#=info#>
<#+	
}

//
// WriteCommentBlock
//
public void WriteCommentBlock(string info)
{
#>

/*

<#=info#>

*/
<#+	
}
//
// WriteImplementationFilePreliminaries
//
public void WriteImplementationFilePreliminaries()
{
	WriteModuleFeatureRequirements();
}

//
// WriteModuleFeatureRequirements
//
public void WriteModuleFeatureRequirements()
{
#>

// ARC is required
#if  ! __has_feature(objc_arc)
#error This file requires ARC. 
#endif

<#+
}

//
// WriteProtocolStart
//
public void WriteProtocolStart(InterfaceFacet facet, string module, bool writeImplementation = false)
{
	if (!writeImplementation) {
		WriteModuleBanner(facet, module);
    }

	string baseProtocol = "System_Object";
	string adoptionProtocolSuffix = "_";
	string adoptionProtocolName = facet.ObjCFacet.Type + adoptionProtocolSuffix;

	if (!writeImplementation) {

		// write adoption protocol
		string protocolSuffix = adoptionProtocolSuffix;
		string protocolName = adoptionProtocolName;
	
		// build list of base protocols 
		string baseProtocols = baseProtocol + protocolSuffix;
		foreach (ImplementedInterfaceFacet interfaceFacet in facet.ImplementedInterfaces) {
			string interfaceName = interfaceFacet.ObjCFacet.Type + protocolSuffix;
			if (Config.GenerateFacetBinding(interfaceFacet)) {
				baseProtocols += (", " + interfaceName);
		   }
			else {
				baseProtocols += (" /*, " + interfaceName + "*/ ");
			}
		}

#>

/*
 A managed interface is represented as follows:

 1. An adoption protocol that advertises that a class has adopted a given protocol. For the reasons 
 given in the notes below this protocol by default declares no members. The code generator will
 use this protocol when declaring classes and method parameters.

 2. An implementation protocol that declares the properties and methods defined by the interface.
 The code generator will use this protocol when declaring variables.

 3. An interface header and implementation body. The explicit class implementation of the managed interface
 can be used to create an instance that conforms to the given interface in order to access explicit properties.

 The above seems to give the best approach for interacting with complex managed interfaces.

 Notes:

 .Net support for explicit interfaces means that a class can inherit two or more different
 signatures for the same property or method from two or more interfaces. 
 This is not supported by Objective-C. 

 A second point is that properties declared in protocols don't get their ivars synthesized.
 This causes warnings to be issued when interface properties are exposed explicitly.

 A third point is that even when we receive a managed interface as a return value from a property 
 or method we still need to provide a full binding in order access those properties and methods.

 A class can test for protocol adoption using Class -conformsToProtocol: using the adoption protocol.
 By casting to the implementation protocol an instance can check for method implementation using respondsToSelector:.

 Properties and method predeclarations can be conditionally included in the adoption protocol if required.

*/


//
// Adoption protocol
//
@protocol <#=protocolName#> <<#=baseProtocols#>>

@optional

#ifdef  DEF_P_AND_M_<#=protocolName.ToUpper()#>
<#+	
    } else {
	
		// write implementation protocol
		string protocolSuffix = "";
		string protocolName = facet.ObjCFacet.Type + protocolSuffix;

		// build list of base protocols 
		string baseProtocols = adoptionProtocolName + ", " + baseProtocol;
		foreach (ImplementedInterfaceFacet interfaceFacet in facet.ImplementedInterfaces) {
		  string interfaceName = interfaceFacet.ObjCFacet.Type + protocolSuffix;
		   if (Config.GenerateFacetBinding(interfaceFacet)) {
				baseProtocols += (", " + interfaceName);
		   }
			else {
				baseProtocols += (" /*, " + interfaceName + "*/ ");
			}
		}
#>

//
// Implementation protocol
//
@protocol <#=protocolName#> <<#=baseProtocols#>>

@optional

<#+		
	}// if !writeAux

}

//
// WriteProtocolEnd
//
public void WriteProtocolEnd(CodeFacet facet, bool writeAux = false)
{
	if (!writeAux) {
#>
#endif

<#+
    } // if !writeAux
#>

@end

<#+
	if (writeAux) {
		WriteModuleFooter();
    }
}


//
// WriteClassStart
//
public void WriteClassStart(CodeFacet facet, string module, bool writeBanner = true)
{
	// Allocate property name list
	this.StaticObjectPropertyStorageNames = new List<string>();

	// prefix defines interface or implementation
	string classPrefix = OutputDeclarationPrefix();
	string superClass = OutputDeclarationSuffix(facet);
	string implementedProtocols = "";

	// implemented protocol support is available but 
	// we may not be quite ready to supply all the framework managed interfaces that
	// are commonly referenced
	bool outputImplementedProtocols = true;
	if (outputImplementedProtocols) {
		implementedProtocols =  OutputImplementedProtocolSuffix(facet);
    }

	 if (writeBanner) {
		WriteModuleBanner(facet, module);
    }

	 if (facet is EnumerationFacet) {
#>

// C enumeration
<#+
		WriteFacetAsEnumeration((EnumerationFacet)facet);
#>

<#+
	}
#>
@<#=classPrefix#> <#=facet.ObjCFacet.Type#><#=superClass#><#=implementedProtocols#>
<#+	
	WriteClassSetup(facet);	
}


//
// WriteClassSetup
// 
public void WriteClassSetup(CodeFacet facet)
{
	WritePragmaMark("Setup");
#>

+ (const char *)monoClassName<#=LT#>
<#+
	if (OutputFileType == OutputType.Implementation) 
	{
		string name = CodeFacet.NormalizeGenericTypesInManagedIdentifier(facet.NameFromType);
#>
{
	return "<#=facet.TypeNamespace#>.<#=name#>";
}
<#+
    }
#>
+ (const char *)monoAssemblyName<#=LT#>
<#+	
	if (OutputFileType == OutputType.Implementation) 
	{
#>
{
	return "<#=AssemblyFacet.Name#>";
}
<#+
    }
}

//
// WriteClassEnd
//
public void WriteClassEnd(CodeFacet facet)
{
	WriteClassTeardown(facet);	
#>
@end
<#+
	WriteModuleFooter();
}

//
// WriteClassTeardown
// 
public void WriteClassTeardown(CodeFacet facet)
{
	if (OutputFileType == OutputType.Implementation) 
	{
	WritePragmaMark("Teardown");
#>

- (void)dealloc
{
<#+
		foreach (string staticObjectPropertyName in StaticObjectPropertyStorageNames)
        {
#>
	<#=staticObjectPropertyName#> = nil;
<#+
        }
#>
}
<#+

	this.StaticObjectPropertyStorageNames = null;
    }
}
//
// WriteFacetAsEnumeration
//
public void WriteFacetAsEnumeration(EnumerationFacet enumeration)
{
	string objCEnumType = ObjCTypeNameFromManagedTypeName(enumeration.UnderlyingType);
	string objCType = ObjCTypeNameFromManagedTypeName(enumeration.Type);

	// output the enums as a C typedef enum.
	if (OutputFileType == OutputType.Interface) 
	{
#>
typedef NS_ENUM(<#=objCEnumType#>, enum<#=objCType#>) {
<#+
		foreach (FieldFacet field in enumeration.Fields) {
			string objCFieldName = ObjCIdentifierFromManagedIdentifier(field.Name);
#>
	<#=objCType#>_<#=objCFieldName#> = <#=field.ConstantValue#>,
<#+
		}
#>
};
<#+
    } 

}

//
// WriteFacetAsAccessor
// 
public void WriteFacetAsAccessor(CodeFacet facet, Dictionary<string, object> options = null)
{
	 Net2ObjC.Accessor accessor = new Net2ObjC.Accessor(this, facet, options);
	 if (!accessor.IsValid) {
			return;
	 }

	// Info comment
#>

	// Managed <#=accessor.Description#> name : <#=accessor.Name#>
	// Managed <#=accessor.Description#> type : <#=WriteFacetTypeInfo(facet)#>
<#+	
	// Interface 
	if (OutputFileType == OutputType.Interface) 
	{
		// instance property
		if (!facet.IsStatic) 
		{
			// avoid overriding NSObject properties as we may generate an attribute mismmatch and
			// trigger a storm of warnings
			string prefix = "";
			if (accessor.BaseProperties.Contains(accessor.GetterName)) {
				prefix = "// Avoid potential property attribute clash // ";
			}
#>
    <#=prefix#>@property <#=accessor.PropertyAttributes#><#=accessor.ObjCTypeDecl#> <#=accessor.GetterName#>;
<#+	  
			return;
        }    
	} 
	else 
	{
		// implementation

		// instance property
		if (!facet.IsStatic) 
		{
			// synthesize ivar property storage
#>
    @synthesize <#=accessor.GetterName#> = <#=accessor.PropertyStorage#>;
<#+		
		} else { // declare static property storage
#>
    static <#=accessor.ObjCTypeDecl#> <#=accessor.PropertyStorage#>;
<#+      
		}
    }

	//
	// write getter method
	//
	if (facet.IsReadable) 
	{
#>
    <#=accessor.ObjCMethodType#> (<#=accessor.ObjCTypeDecl#>)<#=accessor.GetterName#><#=LT#>
<#+		
		if (OutputFileType == OutputType.Implementation) 
		{
			if (facet is PropertyFacet) { 
				// thunking : primitive value types and enumerations are returned by value.
				// other value types, such as DateTime are returned as boxed values
				string thunkTypeDecl = null;
				if (ObjCRepresentationIsPrimitive(facet)) {
					accessor.ManagedValueToObjC = "monoObject";
					thunkTypeDecl = accessor.ObjCTypeDecl;
				} else {
					thunkTypeDecl = "MonoObject *";
				}

				// note that the thunk is valid only for a specific class instance.
				// if the obj-C receiver represents a managed interface then the cached thunk
				// must be regenerated if the thunk id invalid for the receiver mono class.
				if (!facet.IsStatic) {
#>
    {
		typedef <#=thunkTypeDecl#> (*Thunk)(MonoObject *, MonoObject**);
		static Thunk thunk;
		static MonoClass *thunkClass;
		MonoObject *monoException = NULL;
		if (!thunk || thunkClass != self.monoClass) {
			thunkClass = self.monoClass;
			MonoMethod *monoMethod = GetPropertyGetMethod(thunkClass, "<#=accessor.MonoInvocationName#>");
			thunk = (Thunk)mono_method_get_unmanaged_thunk(monoMethod);
		}
		<#=thunkTypeDecl#> monoObject = thunk(self.monoObject, &monoException);
		if (monoException != NULL) @throw(NSExceptionFromMonoException(monoException, @{}));
<#+
				} // end non static property
				else 
				{ // static property
#>
    {
		typedef <#=thunkTypeDecl#> (*Thunk)(MonoObject**);
		static Thunk thunk;
		static MonoClass *thunkClass;
		MonoObject *monoException = NULL;
		if (!thunk || thunkClass != self.monoClass) {
			thunkClass = self.monoClass;
			MonoMethod *monoMethod = GetPropertyGetMethod(thunkClass, "<#=accessor.MonoInvocationName#>");
			thunk = (Thunk)mono_method_get_unmanaged_thunk(monoMethod);
		}
		<#=thunkTypeDecl#> monoObject = thunk(&monoException);
		if (monoException != NULL) @throw(NSExceptionFromMonoException(monoException, @{}));
<#+
				} // end static property
			} // end thunking property
			else 
			{  // field 
				string getFormat;
				if (!facet.IsStatic) {
					getFormat = "[self getMonoField:\"{0}\"]";
				} else {
					getFormat = "[[self class] getMonoClassField:\"{0}\"]";
				}
				string getExpression = String.Format(getFormat, accessor.MonoInvocationName);
#>
    {
		<#=accessor.MonoObjectPtr#><#=ManagedVariableName#> = <#=getExpression#>;
<#+	
			} // end field 

			if (accessor.IsObjectProperty) // object equality test
			{
#>
		<#=accessor.DoPropertyEqualityTest#>					
<#+	
			} // end object equality test
#>
		<#=accessor.PropertyStorage#> = <#=accessor.ManagedValueToObjC#>;

		return <#=accessor.PropertyStorage#>;
	}
<#+	
		} // end implementation
   } // end isReadable

	//
	// write setter method
	//
	if (facet.IsWritable) 
	{

#>
    <#=accessor.ObjCMethodType#> (void)<#=accessor.SetterName#>:(<#=accessor.ObjCTypeDecl#>)<#=ObjCVariableName#><#=LT#>
<#+
		if (OutputFileType == OutputType.Implementation) 
		{
			//
			// Property setter
			//
			if (facet is PropertyFacet) {
				string thunkArgTypeDecl, thunkArg;
				if (ObjCRepresentationIsPrimitive(facet)) {
					thunkArgTypeDecl = accessor.ObjCTypeDecl;
					thunkArg = ObjCVariableName;
				} else {
					thunkArgTypeDecl = "MonoObject *";
					thunkArg = string.Format("[{0} monoObject]", ObjCVariableName);
				} 
				if (!facet.IsStatic) {
#>
	{
		<#=accessor.PropertyStorage#> = <#=ObjCVariableName#>;
		typedef void (*Thunk)(MonoObject *, <#=thunkArgTypeDecl#>, MonoObject**);
		static Thunk thunk;
		static MonoClass *thunkClass;
		if (!thunk || thunkClass != self.monoClass) {
			thunkClass = self.monoClass;
			MonoMethod *monoMethod = GetPropertySetMethod(thunkClass, "<#=accessor.MonoInvocationName#>");
			thunk = (Thunk)mono_method_get_unmanaged_thunk(monoMethod);
		}
		MonoObject *monoException = NULL;
		thunk(self.monoObject, <#=thunkArg#>, &monoException);
		if (monoException != NULL) @throw(NSExceptionFromMonoException(monoException, @{}));
	}
<#+
				} // end non static
				else 
				{ // static
#>
	{
		<#=accessor.PropertyStorage#> = <#=ObjCVariableName#>;
		typedef void (*Thunk)(<#=thunkArgTypeDecl#>, MonoObject**);
		static Thunk thunk;
		static MonoClass *thunkClass;
		if (!thunk || thunkClass != self.monoClass) {
			thunkClass = self.monoClass;
			MonoMethod *monoMethod = GetPropertySetMethod(thunkClass, "<#=accessor.MonoInvocationName#>");
			thunk = (Thunk)mono_method_get_unmanaged_thunk(monoMethod);
		}
		MonoObject *monoException = NULL;
		thunk(<#=thunkArg#>, &monoException);
		if (monoException != NULL) @throw(NSExceptionFromMonoException(monoException, @{}));
	}
<#+
				} // end static
			} // end property 
			else 
			{ 
				//
				// field setter
				//
				string setFormat;
				if (!facet.IsStatic) {
					setFormat = "[self setMonoField:\"{0}\" valueObject:{1}]";
				} else {
					setFormat = "[[self class] setMonoClassField:\"{0}\" valueObject:{1}]";
				}
				string setExpression = String.Format(setFormat, accessor.MonoInvocationName, ManagedVariableName);
#>
	{
		<#=accessor.PropertyStorage#> = <#=ObjCVariableName#>;
		<#=accessor.MonoObjectPtr#><#=ManagedVariableName#> = <#=accessor.ObjCValueToMono#>;
		<#=setExpression#>;          
	}
<#+
			} // end field
		}  // end Implementation
	} // end IsWritable
}
#>
